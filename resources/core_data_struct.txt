Introduction
VRT uses many different types of data—such as world data, graphics data, configuration data—
which each have definite structures, represented as C structures and unions. These are presented
as typedefs in APP_TYPE.H, and APP_API.H which is included by APP_TYPE.H
The data mainly consists of typedefs for the data structures, together with #defines for
specific values within these structures.
Each different type of data is presented separately, with the structures and defines in alphabetical
order.
Although there are many different types of data spread across the different file formats, they all
have considerable similarities. The key concept is the chunk, a structure of data whose contents
are dependant on the field called type. Each type of chunk holds different data, but they all look
like this:
typedef struct
{
unsigned short ChkType, Length;
/* ..... other data ..... */
} T_SOMESORTOFCHUNK;
ChkType defines what sort of chunk this is, and Length shows how many bytes of data there
are in it, including ChkType and itself.
Chunks usually come in lists, terminated by a short value of 0xFFFF after the last chunk. There is
usually at most one of each type of chunk in each list, although there are exceptions.
For example, each object attribute (such as rotations, initial position, SCL) is held in its own
chunk, and each object being a list of chunks terminated by 0xFFFF as above. Each object may
not have every type of chunk, just the ones defined for each attribute it actually possesses. Also,
the order of attributes within an object is not important; it is the presence or absence of the chunk
that determines its effect.

Objects must have a standard attributes chunk, which is defined as a mandatory chunk.
Mandatory chunks are the only exception to the ordering rule; they must be first in any list of
related chunks.
ChkType only determines what type of data is in a chunk in context. While chunk type 0 is a
standard attribute chunk in the world file, it is a points chunk in the shape file and a general
chunk in the configuration file. Most of the time it is invisible, but if an application moves data
around between file types, the chunk types are recognized as invalid and may cause problems.
File header
All Superscape files, except backdrops and applications, start with a 256-byte file header,
containing necessary information about the file. It has the following structure:
T_FILEHEADER
Structure: typedef struct
{
char Text[200];
long Spare[10];
long Symbols;
char Type[4];
unsigned short Machine;
long Revision;
unsigned char Version,SubVersion;
} T_FILEHEADER;
Description: Text An identifying string which marks the file as a Superscape file. It must
start off with the following sequence of characters exactly:
“SuperScape (c) New Dimension Inter”
“national Ltd.\0”
This is followed by a short description of the file’s contents, and then by
“\0\x1A” (NUL EOF). This ensures that typing the file from the DOS prompt
only displays the header text—0x1A is the DOS end-of-file marker.
Spare Reserved. Should be set to 0.
Symbols The offset (from the start of the file, in bytes), of symbol
information—such as object names, SCL comments or variable names—in the
file, or 0 if none.
Type A 4-character file type which can be one of the following:
.VRT VRT file
CNFG Configuration file
DDRV Device driver file
FONT Font file
MESS Message file
PALT Palette file
PRNT Printer driver file
RSRC Resource file (VRT 3-60 and before)
RESC Resource file (VRT 4-00 and later)
SHAP Shape file
SOUN Sound file
SPRT Image (sprite) file
WRLD World file
Machine An identifier for the machine from which the file was last saved.
Currently only value 0 is defined: IBM PC or compatible.
Revision The counter increases by one every time the file is saved.
Version and SubVersion The version of the VRT from which the file was
last saved. For example, set Version to 5 and SubVersion to 50 for VRT version
5.50.


World data
The world data is simply a world file that has been loaded into memory. It is stored in a buffer
pointed to by C_WorldBuffer, which is C_WorldBufLength bytes long. Since you may edit
the world, there is additional space in the buffer over and above that actually required for the
world data, whose length is held in C_WorldLen.
The first 256 bytes of the buffer contain a standard file header, as found on the start of all
Superscape files (see above).
After this comes a list of objects. Each object consists of a list of world chunks, the first of which
must be a standard chunk. After the last chunk is a short value 0xFFFF, marking the end of the
object. The objects are arranged as a tree structure, the links being part of the standard chunk.
Following the objects are a set of symbols. Each symbol list consists of a list of symbols chunks,
terminated by 0xFFFF. The first list is any global symbol information (including layer names).
Then there is a symbols list for each object with symbols, terminated by an 0xFFFF. The end of
this list of lists is itself marked by another 0xFFFF.
Buffer: File header
Standard chunk, object 1 Object 1’s data
Rotations chunk
0xFFFF
Standard chunk, object 2 Object 2’s data
Current colors chunk
SCL chunk
0xFFFF
Symbols: Layer name 1 List of layer names
0xFFFF Empty global list
Name of object 1 Object 1’s symbols
0xFFFF
Name of object 2 Object 2’s symbols
SCL comments
0xFFFF
0xFFFF Empty-end symbols
The chunks in the world data are all members of the union T_WORLDCHUNK. Therefore, a pointer
to this type can be used for any chunk and the relevant element read according to its chunk type.
The ChkType fields for each type of chunk are all in the same place, and can always be read from
the standard chunk element. The T_WORLDCHUNK union looks like this:

typedef union
{
T_STANDARD Std;
T_COLOURS Col;
T_DEFCOLS Def;
T_ROTATIONS Rot;
T_DISTANCE Dis;
T_ANGVELS Ang;
T_SCL SCL;
T_ANIMATIONS Ani;
T_TRIGSCL Loc;
T_TRIGSCL Glo;
T_ANIMCOLS Acl;
T_ATTACHMENTS Att;
T_SHOOTVEC Sho;
T_TEXTINFO Tex;
T_LIGHTSOURCE Lig;
T_INITSIZE Isz;
T_BENDING Ben;
T_VIEWPOINT Vpt;
T_BUBBLE Bub;
T_COLLISION Cln;
T_INITPOS Ips;
T_DYNAMICS Dyn;
T_LITCOLS Lit;
T_DEFLITCOLS Dlc;
T_TEXTURES Txr; (Not used in VRT 5.50)
T_SORTING Sor;
T_TRANSLATE Spx;
T_TRANSLATE Snx;
T_AUTOSOUND Asn;
T_ENTITY Ent;
T_ORIGINALCOL Ocl;
T_PROPERTIES Prp;
T_TEXCOORDS Txc;
T_MATERIAL Mat;
T_PROJECTOR Prj;
T_HORIZON Hrz;
T_FOGVOLUME Fog;
} T_WORLDCHUNK;
For example, you can read the initial X position from the initial position chunk pointed to by a
pointer p (which is of type T_WORLDCHUNK *) using:
XPos=p->Ips.IXPos;
Ips specifies an initial position chunk.

Shape data
The shape data, like the world data, is simply a shape file loaded into memory. The buffer in
which it resides is at C_ShapeBuffer, and is C_ShapeBufLength bytes long. Of this,
C_ShapeLen bytes are actually occupied by shape data.
The shape data consists of a standard file header, followed by a list of shapes. Each shape is, in
turn, a list of shape chunks (which are detailed below) terminated by a short value of 0xFFFF as
usual. The end of the entire list is signified by a single short of value 0xFFFF.
Shapes have three major components: points, lines and facets.
Points define positions within the shape for the construction of lines, and come in two types.
Relative points, the first type, are specified in terms of the overall size of the outer cube of the
object. These change position if the object is scaled. The proportions of the x, y and z axes to be
added to make up the point are specified as 1/16384ths. Thus a relative point with position
(8192,8192,8192) is at the exact center of the object.
Geometric points are constructed as a position along a straight line between two existing points.
The position on the line is a fraction whose denominator is a power of two. These points are much
faster to process than relative points, at around 11% of a basic rotation calculation in the worst
case. If the numerator of the fraction is 1, then the processing time becomes almost negligible.
They are not affected by bending, however.
The first eight points (numbers 0–7) are always the eight outer points of the surrounding cuboid.
They are defined as follows:
Point 0 - Origin
Point 1 - Origin + Z size vector
Point 2 - Origin + Y size vector
Point 3 - Origin + Y size vector + Z size vector
Point 4 - Origin + X size vector
Point 5 - Origin + X size vector + Z size vector
Point 6 - Origin + X size vector + Y size vector
Point 7 - Origin + X size vector + Y size vector + Z size vector
Points are joined in pairs by lines, which are clipped if necessary and assembled into facets.
Facets are visible from one side only, and are made from lines. The visible side is the one around
which the lines are defined in anti-clockwise order. Each defined line may be used in either
direction, removing redundant line definitions.
The chunks in the shape data are all members of the union T_SHAPECHUNK. Thus, a pointer to
this type can be used for any chunk and the relevant element read according to its chunk type. The
ChkType fields for each different type of chunk are all in the same place, so this can always be
read by reading the chunk type from the points chunk element. The T_SHAPECHUNK union looks
like this:
typedef union
{
T_POINTSCHK Pnt;
T_LINECHK Lin;
T_FACETCHK Fac;
T_COLOURS Col;
T_LITCOLS Lit;
T_TEXTINFO Tex;
T_SHAPESIZE Siz;
T_SCL SCL;
T_ANIMCOLS Acl;
T_TEXTURES Txr; (Not used in VRT 5.50)
T_TRANSLATE Spx; (Not used in VRT 5.50)
T_NORMALS Nor;
} T_SHAPECHUNK;
For example, you can access the number of facets from a facet chunk pointed to by p (which is of
type T_SHAPECHUNK *), using:
Facets=p->Fac.NumFacets;
Fac specifies which type of chunk you wish to examine.

T_PALETTE
Type: E_PCPALETTE
Structure: struct
{
unsigned short ChkType,Length;
unsigned char Palette[0x300];
} T_PALETTE;
Description: Contains information about the actual hardware palette to use, specifying the
possible colors for any one pixel on the screen.
ChkType The chunk type (E_PCPALETTE)
Length The length of the chunk, including ChkType and itself.
Palette An array of 256 triplets of R,G,B palette information. These are
normalized so that a value of 0xFF is the maximum intensity for that color
component, and 0 is the minimum, regardless of the actual display device used.
The first sixteen colors are defined as system colors and should not be changed by
the user since they are used for system resources such as dialog boxes and text
messages. Only colors 0 (transparent) and 1 (black) should be used in the world.
The first sixteen colors are defined as follows:
No Name RGB values

0 E_COLTRANSPARENT 0x00 0x00 0x00
1 E_COLBLACK 0x00 0x00 0x00
2 E_COLBLUE 0x00 0x00 0xA7
3 E_COLRED 0xAB 0x00 0x00
4 E_COLGREEN 0x00 0x7F 0x00
5 E_COLMAGENTA 0xAB 0x00 0xAB
6 E_COLYELLOW 0xA3 0x00 0xA7
7 E_COLGREY 0xAA 0xAA 0xAA
8 E_COLDKGREY 0x55 0x55 0x55
9 E_COLLTBLUE 0x00 0xBB 0xFF
10 E_COLBRBLUE 0x00 0x00 0xFF
11 E_COLBRRED 0xFF 0x00 0x00
12 E_COLBRGREEN 0x00 0xFF 0x00
13 E_COLLTGREY 0xCC 0xCC 0xCC
14 E_COLBRYELLOW 0xFF 0xFF 0x00
15 E_COLWHITE 0xFF 0xFF 0xFF

(Color 0 is transparent)
Dialog boxes, messages, and system resources should only use these colors, since
none of the other colors can be guaranteed to be visible.